# Функции в Python
# Функции описываются с помощью ключевого слова def, функция должна иметь имя
# Аргументы бывают двух типов: обычный аргумент, и аргумент по умолчанию
def foo(arg, default=10):
    """
    Документация функции (здесь используются \"\"\" \"\"\" тройные кавычки)
    :param arg:
    :param default:
    :return:
    """
    print("arg=", arg)
    print("default=", default)
    arg **= 2
    return arg  # return необязательный учатник функции
    # return применяется для возврата значения
    # возвращать можно несколько значений
    # Пример: return a,b,c,None
    # По сути такая запись эквивалентина такой записи: return (a,b,c,None)
    # (возвращает кортеж из значений)


if __name__ == '__main__':
    # Структуры данных
    # Stack - LIFO (Last In, First Out) - стэк
    # Queue - FIFO (First In, First Out) - очередь
    # List - список
    # Dictionary - словарь (ассоциативный массив)
    # Tuple - кортеж
    # Set - множество
    # Tree - дерево (деревья в программировании достигаются с помощью деревьев)

    # Форматы хранения, передачи, описания данных
    # class MyClass:
    #   self.a=10
    #   self.b=15
    # XML (eXtended Markup Language)
    # пример
    # <class>
    #   <className>
    #       MyClass
    #   <className>
    #   <attributes>
    #       <name>a</name>
    #       <value>10</value>
    #       <name>b</name>
    #       <value>15</value>
    #   </attributes>
    # </class>
    # JSON - JavaScript Object Notation
    # Пример:
    #   {"className" : "MyClass",
    #       "attributes" : {
    #           "name" : a,
    #           "value": 10,
    #           "name" : b,
    #           "value": 15,
    #       }
    #   }
    # JSON напоминает словарь в Python, поэтому его сейчас чаще используют
    di = {"asd": 123}  # словарь dict()
    print(type(di) is dict)  # Проверка типа
    print(type(di) == dict)  # Проверка типа через равно
    print(type)
    a = [1, 2, 4, 2.3, 0, -1]
    print(a)
    for element in a:
        print(element)
    # Срез. Срезы можно применять к перебираемым объектам (списки, строки, кортежи)
    # Синтаксис среза 'slice' var[<начало>:<конец>:<шаг>]
    # Шаг может быть отрицательным (по умолчанию = 1)
    #
    print(a[::-1])  # Вывести список наоборот (срез)
    print(a[2:])
    print(a[2:5])
    print(a[5:2:-1])
    string = "Hello, World!!!"
    print(string, string[::-1])
    ob = {"a": 1, "b": 2}
    # print(ob, ob[::-1]) # Словарь не поддерживает срезы
    for key, value in zip(ob.keys(), ob.values()):  # Как перебирать словрь
        print(key, value)

    # Функция zip(iter1, iter2) Может принимать несколько перебираемых объекто
    # zip - транспонирует списки (т.е. возвращает кортеж из i-ых элементов от каждого списка
    # пример:
    #   [1,2]
    #   [3,4] получим , на первой итерации [1,3], на второй [2,4]
    # Методы словаря
    di.popitem()  # возвращает кортеж, состоящий из последнего элемента
    # словаря в виде (key, value), если словарь пуст,
    #  то возбуждается исключение (появляется ошибка)

    # Обращение к элементу
    # di['asd'] # вызывает исключение (небезопасно)
    di.get('asd')  # Возвращает значение, если оно имеется, иначе None (безопасно)

    # Добавление новых значений
    di['asf'] = 123

    # Удаление элемента из словаря по ключус дальнейшим возвращение (т.е. его можно дальше использовать, как отдельный элемент)
    di.pop('asf')
    # Если элемента нет, то возвращает None

    print(di.keys())  # Возвращает список ключей словаря
    print(di.values())  # Возвращает список значений словаря

    di['a'] = 1234
    di['b'] = [1, 2, 3, 4]

    # Длина словаря
    print(len(di), di.__len__())  # Функция len() вызывает магический метод __len__() (два нижних подчеркивания)
    # Функцию len() можно применить ко всем объектам с определенным методом __len__()

    # Методы списка
    li = [1, 2, 3, 4, 5, -1, 53.14234e-8]

    li.append(1)  # Добавление в конец списка
    li.insert(0, 3)  # Добавление в позицию list.insert(index, obj)
    li.remove(1)  # Удаление из списка объекта, равному указанному (удаляет один объект)
    li.pop(0)  # Удаление объекта из списка по индексу
    li.count(3)  # Подсчет количества указанных элементов
    li.sort()  # Сортировка списка (по умлочанию по возрастанию)
    # list.sort(key=func, reverse=[True, False])
    # Чтобы отсортировать список по убыванию li.sort(reverse=True)
    # Чтобы отсортировать список по особому li.sort(key=func)
    # key принимает на вход функцию
    # пример: li = [1,-23,4,124,-42,54,-1,0], отсортировать список по модулю (игнорируя знак)
    # li.sort(key=abs) получим [0, 1, -1, 4, -23, -42, 54, 124], т.е. сначала применяется функция, которую мы передали
    # потом сортируется список по результатам выполнения этой функции
    li.copy() # ВОзвращает копию списка (поверхностную)
    li.extend('1234') # Принимает на вход перебираемые
    # объекты (строки, списки, кортежи) и добавляет поэлементно в конец списка
    # пример: a = [1,2,4]
    # a.extend('bdf')
    # ИТОГ: [1,2,4,'b','d','f']
    li.pop() # list.pop(index=-1). Выталкивает элемент по его индексу. По умолчанию выталкивает последний элемент
    li.reverse() # Переворачивает список
    li.clear() # Очищает список